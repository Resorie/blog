{"meta":{"title":"Resory","subtitle":null,"description":"","author":"Sya Resory","url":"https://resorie.github.io/blog","root":"/blog/"},"pages":[{"title":"关于我","date":"2020-10-04T01:04:16.301Z","updated":"2020-10-04T01:04:16.301Z","comments":true,"path":"about/index.html","permalink":"https://resorie.github.io/blog/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-10-03T05:54:57.266Z","updated":"2020-10-03T05:54:57.266Z","comments":false,"path":"categories/index.html","permalink":"https://resorie.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-03T05:54:14.292Z","updated":"2020-10-03T05:54:14.292Z","comments":false,"path":"tags/index.html","permalink":"https://resorie.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"浅谈珂朵莉树（ODT）","slug":"about-ODT","date":"2020-10-03T05:44:09.000Z","updated":"2020-10-07T13:47:22.844Z","comments":true,"path":"posts/about-ODT/","link":"","permalink":"https://resorie.github.io/blog/posts/about-ODT/","excerpt":"0x00 Prologue在太阳西斜的这个世界里， 置身天上之森。 等这场战争结束之后， 不归之人与望眼欲穿的众人， 人人本着正义之名， 长存不灭的过去、逐渐消逝的未来。 我回来了，纵使日薄西山，即便看不到未来， 此时此刻的光辉，盼君勿忘。 这几天闲着慌，就去学了学珂朵莉树，作为一个很有用的骗分数据结构，个人认为还是有必要学一学的。","text":"0x00 Prologue在太阳西斜的这个世界里， 置身天上之森。 等这场战争结束之后， 不归之人与望眼欲穿的众人， 人人本着正义之名， 长存不灭的过去、逐渐消逝的未来。 我回来了，纵使日薄西山，即便看不到未来， 此时此刻的光辉，盼君勿忘。 这几天闲着慌，就去学了学珂朵莉树，作为一个很有用的骗分数据结构，个人认为还是有必要学一学的。 反正又不难 0x01 What is it?珂朵莉树起源于Codeforces 896 C，由于出题人的CF id为Old Driver，因此又被称为Old Driver Tree（ODT）。 原题需要我们实现一种数据结构，可以快速维护以下操作：（保证数据随机） 区间加； 区间赋值； 求区间第 $k$ 小； 求区间 $k$ 次方和。 很明显，普通的线段树等数据结构都很难实现这种要求，但是这种似乎很复杂的数据结构，在出题人这位毒瘤眼中竟然可以用…… 暴力实现？ 珂朵莉树的思想在于把一段连续的值相同的区间用一个结构体来存储，由于数据随机且有大量区间赋值操作，这样的结构体数量会大大减少，从而保证了珂朵莉树接近线性的时间复杂度。 乍一看，珂朵莉树似乎并不像是一个树形数据结构，但因为它一般基于 $std::set$ 来实现，而 $std::set$ 本质是红黑树，所以也跟“树”勉强搭得上边。 0x02 如何实现？珂朵莉树的精髓在于区间推平操作会产生大量的元素值相同的区间，因此我们用三个变量 $l,r,v$ 来表示一个下标为 $[l,r]$ 中元素值为 $v$ 的区间。接着我们把这些三元组存储到 $std::set$ 中。写成代码就是这样的： 12345678struct node &#123; int l,r; mutable int v; // 这里mutable关键字保证了可以直接在set中修改v的值 node() &#123;&#125; node(int L,int R,int V): l(L),r(R),v(V) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125; // 按照区间所在的位置排序&#125;; typedef set &lt; node &gt; :: iterator iter; // 简化迭代器set &lt; node &gt; s; // 存储到std::set中 比如当输入数据为1 2 2 2 3 3 4 4时， $set$ 内存储的数据就是这样的： 操作1：split然而，我们操作的区间并不总是正好覆盖我们存储的区间。因此我们需要一个函数来实现分裂开每个区间的操作，也就是split函数。split函数接受一个参数 $pos$ ，然后把包含 $pos$ 的区间 $[l,r]$ “分裂”成 $[l,pos)$ 和 $[pos,r]$ ： 123456789iter split(ll pos) &#123; iter it = s.lower_bound(node(pos,0,0)); // lower_bound寻找包含pos的区间 if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; // 如果已经存在就直接返回 it --; // 往前数一个才是我们想要的 ll l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); // 删除原来的 s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first; // 分裂成两个并返回后面一个的迭代器&#125; 对于刚才那个图，如果我们执行split(4)，那么他就会变成这样： 这里的运行流程：lower_bound找到区间 $$ ，往前回滚找到 $$ ，并将其修改成 $$ 和 $$ 。 在进行区间操作时，我们常常要左右端点各split一次，此时我们要先split右端点，否则左端点的迭代器可能会失效而导致错误。 操作2：assign很明显，如果操作中全是split的话，区间数会越来越多，复杂度必然爆炸。这时我们就需要区间赋值操作减少区间数量：assign。 assign函数接受三个参数，表示区间和要赋的值。赋值时，把左右端点split一下，然后把中间的部分变成一个新的区间就行了： 12345void assign(ll l,ll r,ll v) &#123; iter itr = split(r + 1),itl = split(l); // 左右端点各split一遍 s.erase(itl,itr); // 两端点之间的节点全部删去 s.insert(node(l,r,v)); // 插入新的区间&#125; 还是刚刚那个图，如果我们执行assign(3,5,5)，就变成了这个亚子： 其他操作：暴力出奇迹区间加：一个一个加一遍就完事了 1234void add(int l,int r,int x) &#123; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) itl -&gt; v += x;&#125; 区间第 $k$ 大：塞到 $vector$ 里排序就完事了 1234567891011int kth(int l,int r,int k) &#123; vector &lt; pair &lt; int,int &gt; &gt; vec; // pair存储值以及区间长度 iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) vec.push_back(make_pair(itl -&gt; v,itl -&gt; r - itl -&gt; l + 1)); sort(vec.begin(),vec.end()); // 默认优先按照第一关键字排序 for(int i = 0;i &lt; vec.size();i ++) &#123; k -= vec[i].second; if(k &lt;= 0) return vec[i].first; &#125;&#125; 区间 $k$ 次方和：每个取出来做快速幂求和就完事了 1234567int sum(int l,int r,int x,int y) &#123; // x次方和除以y的余数 int res = 0; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) res = (res + (itl -&gt; r - itl -&gt; l + 1) % y * fpow(itl -&gt; v,x,y) % y) % y; // fpow就是快速幂 return res;&#125; 真的是暴力出奇迹……然而因为split和assign的存在， $set$ 中的区间数量也不会太多，所以速度可以保证。不过如果数据不随机，珂朵莉树还是很容易被hack掉的。比如CF896C中提供了一个随机数生成器就是为了防止hack。 最后附上CF896C的全部代码： 查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long ll;struct node &#123; ll l,r; mutable ll v; node() &#123;&#125; node(ll _l,ll _r,ll _v): l(_l),r(_r),v(_v) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125;&#125;; typedef set &lt; node &gt; :: iterator iter;set &lt; node &gt; s;ll n,m,seed,vmax,op,l,r,x,y;ll a[100005];ll rnd(ll mod) &#123; ll ret = seed; seed = (seed * 7 + 13) % 1000000007; return ret % mod + 1;&#125;ll fpow(ll a, ll b, ll mod) &#123; ll res = 1,ans = a % mod; while(b) &#123; if(b &amp; 1) res = res * ans % mod; ans = ans * ans % mod; b &gt;&gt;= 1; &#125; return res;&#125;iter split(ll pos) &#123; iter it = s.lower_bound(node(pos,0,0)); if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; it --; ll l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first;&#125;void assign(ll l,ll r,ll v) &#123; iter itr = split(r + 1),itl = split(l); s.erase(itl,itr); s.insert(node(l,r,v));&#125;void add(ll l,ll r,ll x) &#123; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) itl -&gt; v += x;&#125;ll kth(ll l,ll r,ll k) &#123; vector &lt; pair &lt; ll,ll &gt; &gt; vec; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) vec.push_back(make_pair(itl -&gt; v,itl -&gt; r - itl -&gt; l + 1)); sort(vec.begin(),vec.end()); for(int i = 0;i &lt; vec.size();i ++) &#123; k -= vec[i].second; if(k &lt;= 0) return vec[i].first; &#125;&#125;ll sum(ll l,ll r,ll x,ll y) &#123; ll res = 0; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) res = (res + (itl -&gt; r - itl -&gt; l + 1) % y * fpow(itl -&gt; v,x,y) % y) % y; return res;&#125;int main() &#123; scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;seed,&amp;vmax); for(int i = 1;i &lt;= n;i ++) &#123; a[i] = rnd(vmax); s.insert(node(i,i,a[i])); &#125; for(int i = 1;i &lt;= m;i ++) &#123; op = rnd(4),l = rnd(n),r = rnd(n); if(l &gt; r) swap(l,r); if (op == 3) x = rnd(r - l + 1); else x = rnd(vmax); if (op == 4) y = rnd(vmax); switch(op) &#123; case 1: add(l,r,x); break; case 2: assign(l,r,x); break; case 3: printf(&quot;%lld\\n&quot;,kth(l,r,x)); break; case 4: printf(&quot;%lld\\n&quot;,sum(l,r,x,y)); break; &#125; &#125; return 0;&#125; 0x03 更广泛的运用1. CF915E Physical Education Lessons 有两种操作，每次操作把区间内的值全部赋成0或1，求每次操作后整个序列内元素的和。 区间赋值+区间求和，简直是珂朵莉树的模板！不过在这题中，我们可以把sum函数简化掉，只需要在assign中求和即可。 查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;typedef long long ll;struct node &#123; ll l,r; mutable ll v; node() &#123;&#125; node(ll _l,ll _r,ll _v): l(_l),r(_r),v(_v) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125;&#125;; typedef set &lt; node &gt; :: iterator iter;set &lt; node &gt; s;ll n,q,sum; // sum存储区间和iter split(ll pos) &#123; iter it = s.lower_bound(node(pos,0,0)); if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; it --; ll l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first;&#125;void assign(ll l,ll r,ll v) &#123; int cnt = 0,len = 0; // cnt代表区间内的和，len代表区间长度 iter itr = split(r + 1),itl = split(l); for(iter it = itl;it != itr;it ++) &#123; len += (it -&gt; r - it -&gt; l + 1); cnt += it -&gt; v * (it -&gt; r - it -&gt; l + 1); &#125; s.erase(itl,itr); s.insert(node(l,r,v)); if (v == 1) sum += (len - cnt); else sum -= cnt; // 更新sum的值&#125;int main() &#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;q); sum = n,s.insert(node(1,n,1)); for(int l,r,k;q;q --) &#123; scanf(&quot;%lld%lld%lld&quot;,&amp;l,&amp;r,&amp;k); assign(l,r,k == 1 ? 0 : 1); printf(&quot;%lld\\n&quot;,sum); &#125; return 0;&#125; 2. 洛谷P1047 校门外的树我知道这题可以用模拟差分线段树分块做 但如果把区间长度 $L$ 的范围加大到$10^9$，这些方法就不行了。这时我们就要祭出今天的主角：珂朵莉树。 由于 $m$ 的范围并没有那么大，因此区间的数量并不会那么多（在 $O(m)$ 级别）。由于题目只要求实现区间清零的操作，我们可以直接仿照上个例子来完成。 查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;struct node &#123; int l,r; mutable int v; node() &#123;&#125; node(int _l,int _r,int _v): l(_l),r(_r),v(_v) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125;&#125;; typedef set &lt; node &gt; :: iterator iter;set &lt; node &gt; s;int L,m,sum;iter split(int pos) &#123; iter it = s.lower_bound(node(pos,0,0)); if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; it --; int l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first;&#125;void assign(int l,int r) &#123; int cnt = 0,len = 0; iter itr = split(r + 1),itl = split(l); for(iter it = itl;it != itr;it ++) &#123; len += (it -&gt; r - it -&gt; l + 1); cnt += it -&gt; v * (it -&gt; r - it -&gt; l + 1); &#125; s.erase(itl,itr); s.insert(node(l,r,0)); sum -= cnt;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;L,&amp;m); sum = L + 1,s.insert(node(0,L,1)); for(int l,r;m;m --) &#123; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); assign(l,r); &#125; printf(&quot;%d\\n&quot;,sum); return 0;&#125; 如果真的遇到这道题，且不保证数据随机时，珂朵莉树有可能被hack掉，此时这题的正解应该是离散化+差分。 3. 洛谷P2572 [SCOI2010]序列操作一道不错的练习珂朵莉树骗分的题目。很明显，第0,1,3个操作都是珂朵莉树的板子，而其他两个操作只要稍作修改就行了： 查看代码 区间取反：1234void reverse(int l,int r) &#123; // 挨个取出来取反 iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) itl -&gt; v ^= 1; // 值异或1是个简单的取反方法&#125;求区间最大连续1的长度：12345678int query(int l,int r) &#123; int ans = 0,sum = 0; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) // 挨个取出来计数 if(itl -&gt; v) sum += itl -&gt; r - itl -&gt; l + 1; else ans = ans &gt; sum ? ans : sum,sum = 0; return ans &gt; sum ? ans : sum;&#125; 对于本题，有两个注意点：下标从0开始，因此处理时要全部+1；原题出自2010年四川省选，当时的数据较弱，ODT可以轻松过；但在洛谷上，本题数据经过精心构造，普通ODT只能过3个点。这也是一般ODT只能用作骗分手段的原因。 4. 洛谷P2787 语文1（chin1）- 理理思维又是一道ODT骗分题。前两个操作都是ODT基操，第三个操作开桶排序即可。 查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std;struct node &#123; int l,r; mutable int v; node() &#123;&#125; node(int _l,int _r,int _v): l(_l),r(_r),v(_v) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125;&#125;; typedef set &lt; node &gt; :: iterator iter;set &lt; node &gt; s;string buf;int n,m;int a[100005];inline int read() &#123;#define gc c = getchar() int d = 0,f = 0,gc; while(c &lt; 48 || c &gt; 57) f |= (c == &#x27;-&#x27;),gc; while(c &gt; 47 &amp;&amp; c &lt; 58) d = (d &lt;&lt; 1) + (d &lt;&lt; 3) + (c ^ 48),gc;#undef gc return f ? -d : d;&#125;inline int todigit(char c) &#123; // alpha -&gt; digits if(&#x27;A&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;Z&#x27;) return c - &#x27;A&#x27; + 1; if(&#x27;a&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;z&#x27;) return c - &#x27;a&#x27; + 1;&#125;iter split(int pos) &#123; iter it = s.lower_bound(node(pos,0,0)); if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; it --; int l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first;&#125;void assign(int l,int r,int v) &#123; iter itr = split(r + 1),itl = split(l); s.erase(itl,itr); s.insert(node(l,r,v));&#125;inline int query(int l,int r,int k) &#123; int sum = 0; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) if(itl -&gt; v == k) sum += itl -&gt; r - itl -&gt; l + 1; return sum;&#125;void bsort(int l,int r) &#123; int pos = l,cnt[27]; memset(cnt,0,sizeof(cnt)); iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl = erase(itl)) cnt[itl -&gt; v] += itl -&gt; r - itl -&gt; l + 1; for(int i = 1;i &lt;= 26;i ++) if(cnt[i]) s.insert(node(pos,pos + cnt[i] - 1,i)),pos += cnt[i];&#125;int main() &#123; n = read(),m = read(); cin &gt;&gt; buf; for(int i = 1;i &lt;= n;i ++) s.insert(node(i,i,todigit(buf[i - 1]))); for(int op,x,y;m;m --) &#123; op = read(),x = read(),y = read(); char k; if(op != 3) &#123; cin &gt;&gt; k; k = todigit(k); &#125; switch(op) &#123; case 1: printf(&quot;%d\\n&quot;,query(x,y,k)); break; case 2: assign(x,y,k); break; case 3: bsort(x,y); break; &#125; &#125; return 0;&#125; 0x04 Epilogue我永远喜欢珂朵莉！（雾 珂朵莉树作为一个较为简单的数据结构，是在OI比赛中骗分的一个不错的工具蒟蒻选手的福音。在许多复杂的线段树题目中，它能够体现出清晰易懂、代码量小的优势。 所以，大家快来膜拜lxl，lxl是我们的光！","categories":[{"name":"编程","slug":"编程","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/"},{"name":"数据结构","slug":"编程/数据结构","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://resorie.github.io/blog/tags/OI/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/"},{"name":"数据结构","slug":"编程/数据结构","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://resorie.github.io/blog/tags/OI/"}]}