{"meta":{"title":"Resory","subtitle":null,"description":"","author":"Sya Resory","url":"https://resorie.github.io/blog","root":"/blog/"},"pages":[{"title":"关于我","date":"2020-10-04T01:04:16.301Z","updated":"2020-10-04T01:04:16.301Z","comments":true,"path":"about/index.html","permalink":"https://resorie.github.io/blog/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-03T05:54:14.292Z","updated":"2020-10-03T05:54:14.292Z","comments":false,"path":"tags/index.html","permalink":"https://resorie.github.io/blog/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-10-03T05:54:57.266Z","updated":"2020-10-03T05:54:57.266Z","comments":false,"path":"categories/index.html","permalink":"https://resorie.github.io/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"【题解】[NOI2018]屠龙勇士","slug":"soln-P4774","date":"2020-10-08T03:44:07.000Z","updated":"2020-12-18T13:04:10.308Z","comments":true,"path":"posts/soln-P4774/","link":"","permalink":"https://resorie.github.io/blog/posts/soln-P4774/","excerpt":"","text":"题目链接 算是一个比较简单的黑题，数论萌（神）新（仙）练（秒）手（切）题。 前置知识：扩展中国剩余定理（excrt）求解一个线性同余方程组： \\left\\{ \\begin{array}{lr} x \\equiv q_1 \\pmod {p_1}, &\\\\ x \\equiv q_2 \\pmod {p_2}, &\\\\ x \\equiv q_3 \\pmod {p_3}, &\\\\ \\dots &\\\\ x \\equiv q_n \\pmod {p_n}. \\end{array} \\right.（$q_1,q_2,q_3\\dots,q_n$ 不两两互质） 由于并没有简单的直接求解的办法，所以考虑分开求解。 假设求解到第 $i$ 个方程，前面 $i-1$ 个方程结果为 $ans$ ，模数的 $\\operatorname{lcm}$ 是 $M$ ，则可以列出一个方程组： \\left\\{ \\begin{array}{lr} x \\equiv ans \\pmod {M}, &\\\\ x \\equiv q_i \\pmod {p_i}. \\end{array} \\right.为了简便，我们用 $a_{1,2}$ 代表余数， $b_{1,2}$ 代表模数，则有： x = k_1 \\cdot b_1+a_1=k_2 \\cdot b_2+a_2\\ (k_{1,2} \\in \\mathbb Z)移项得： k_1 \\cdot b_1 - k_2 \\cdot b_2 = a_2-a_1令 $G=\\gcd(b_1,b_2)$ ，若 $G \\not| (a_2-a_1)$ ，则无解。否则用 exgcd 求解方程 $b_1x’+b_2y’=G$，可得 $k_1=\\dfrac{x’ \\cdot (a_2-a_1)}{G}$ ，带回即可求出 $x$ 的值。 本题题解Part 1 初始化首先我们发现，杀死龙的顺序是确定的，每次杀龙的剑也是确定的，这就说明我们可以用 $multiset$ 模拟选剑的过程，每次 upper_bound 一下就行了。 123456789101112131415161718192021ll n,m,a[maxn],p[maxn],award[maxn],atk[maxn];multiset &lt; ll &gt; sword;void input() &#123; n = func::read(),m = func::read(); // read是定义在命名空间func中的快读函数 for(int i = 1;i &lt;= n;i ++) a[i] = func::read(); // 第i条龙的生命值 for(int i = 1;i &lt;= n;i ++) p[i] = func::read(); // 第i条龙的恢复能力 for(int i = 1;i &lt;= n;i ++) award[i] = func::read(); // 杀死第i条龙的奖励 for(int i = 1;i &lt;= m;i ++) sword.insert(func::read()); // 把所有剑的攻击力存储进multiset中&#125;void init() &#123; multiset &lt; ll &gt;::iterator it; for(int i = 1;i &lt;= n;i ++) &#123; it = sword.upper_bound(a[i]); // upper_bound出第i把剑的攻击力 if(it != sword.begin()) it --; atk[i] = *it; sword.erase(it); sword.insert(award[i]); // 插入杀死第i条龙的奖励 &#125;&#125; 我们又发现，杀死龙的步骤为：以 $atk_i$ 的攻击力攻击 $x$ 下，回复若干次 $p_i$ 生命值，生命值变为 $0$ 。这是不是感觉很耳熟？没错，这就是一个同余方程。我们可以根据这个过程列出这样一个方程： atk_i \\cdot x \\equiv a_i \\pmod{p_i}然而这并不符合 excrt 的规范，因此我们可以移项，两边同时乘上 $atk_i$ 关于 $p_i$ 的 $atk_i^{-1}$ ： x \\equiv a_i \\cdot atk_i^{-1} \\pmod{p_i}于是我们得到了得到方程组的代码： 1234567891011bool init_equotion() &#123; for(int i = 1;i &lt;= n;i ++ ) &#123; ll g = func::gcd(p[i],a[i]); // 此段代码中gcd定义在命名空间func中 g = func::gcd(g,atk[i]); a[i] /= g,p[i] /= g,atk[i] /= g; if(func::gcd(atk[i],p[i]) != 1) return false; // 不互质则不存在逆元 返回false表示无解 q1[i] = func::fmul(a[i],func::inv(atk[i],p[i]),p[i]); // 处理方程组 p1[i] = p[i]; &#125; return true;&#125; Part 2 一些特例我们发现，有的数据并不保证 $a_i\\le p_i$ ，这时可能就会出现一种情况：龙的生命值依旧大于0，但是已经和 $p_i$ 同余了。 怎么办呢？ 多半是废了！ 但是，经过仔细观察数据范围，可以发现，对于所有不满足 $a_i\\le p_i$ 的数据，都保证 $p_i=1$ ！这意味着我们可以直接特判掉这些情况，答案即为 $\\max\\left\\{\\left\\lfloor\\dfrac{a_i}{atk_i}\\right\\rfloor\\right\\}$。代码如下： 123456789101112namespace sp &#123; bool check() &#123; // 检查是否符合特殊情况 for(int i = 1;i &lt;= n;i ++) if(p[i] != 1) return false; return true; &#125; void solve_sp() &#123; ll ans = -1; for(int i = 1;i &lt;= n;i ++) ans = func::max(ans,(a[i] + atk[i] - 1) / atk[i]); printf(&quot;%lld\\n&quot;,ans); &#125;&#125; Part 3 解决普遍情况当解决完特殊情况并且处理完方程组后，我们就可以套上 excrt 的板子大干一场了： 123456789101112131415161718192021222324252627282930void excrt() &#123; ll M = p1[1]; ll ans = q1[1]; for(int i = 2;i &lt;= n;i ++) &#123; ll k1,x,y; // 按照excrt的方法求解 ll g = func::exgcd(M,p1[i],x,y); ll c = (q1[i] - ans % p1[i] + p1[i]) % p1[i]; if(c % g != 0) &#123; puts(&quot;-1&quot;); return ; &#125; // 无解 k1 = func::fmul(x,c / g,p1[i] / g); // 龟速乘 防爆long long ans = M * k1 + ans; M = M / g * p1[i]; ans = (ans % M + M) % M; &#125; ans = (ans % M + M) % M; printf(&quot;%lld\\n&quot;,ans);&#125;void solve() &#123; sword.clear(); n = func::read(),m = func::read(); for(int i = 1;i &lt;= n;i ++) a[i] = func::read(); for(int i = 1;i &lt;= n;i ++) p[i] = func::read(); for(int i = 1;i &lt;= n;i ++) award[i] = func::read(); for(int i = 1;i &lt;= m;i ++) sword.insert(func::read()); func::init(); if(sp::check()) sp::solve_sp(); else if(init_equotion()) excrt(); else puts(&quot;-1&quot;);&#125; 完整代码： 查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;set&gt;typedef long long ll;using std::multiset;const int maxn = 100005;ll t,n,m,a[maxn],p[maxn],award[maxn],atk[maxn];multiset &lt; ll &gt; sword;namespace func &#123; inline ll max(ll a,ll b) &#123; return a &gt; b ? a : b; &#125; inline ll read() &#123;#define gc c = getchar() ll d = 0; int f = 0,gc; while(c &lt; 48 || c &gt; 57) f |= (c == &#x27;-&#x27;),gc; while(c &gt; 47 &amp;&amp; c &lt; 58) d = (d &lt;&lt; 1) + (d &lt;&lt; 3) + (c ^ 48),gc;#undef gc return f ? -d : d; &#125; ll gcd(ll a,ll b) &#123; if(!b) return a; return gcd(b,a % b); &#125; ll exgcd(ll a,ll b,ll&amp; x1,ll&amp; y1) &#123; if(!b) &#123; x1 = 1,y1 = 0; return a; &#125; ll x2,y2,ans = exgcd(b,a % b,x2,y2); x1 = y2; y1 = x2 - a / b * y2; return ans; &#125; ll inv(ll a,ll p) &#123; ll x,y; exgcd(a,p,x,y); return (x % p + p) % p; &#125; ll fmul(ll a,ll b,ll mod) &#123; ll rep = 0; while(b) &#123; if(b &amp; 1) rep = (rep + a) % mod; a = (a &lt;&lt; 1) % mod,b &gt;&gt;= 1; &#125; return rep; &#125; void init() &#123; multiset &lt; ll &gt;::iterator it; for(int i = 1;i &lt;= n;i ++) &#123; it = sword.upper_bound(a[i]); if(it != sword.begin()) it --; atk[i] = *it; sword.erase(it); sword.insert(award[i]); &#125; &#125;&#125;namespace sp &#123; bool check() &#123; for(int i = 1;i &lt;= n;i ++) if(p[i] != 1) return false; return true; &#125; void solve_sp() &#123; ll ans = -1; for(int i = 1;i &lt;= n;i ++) ans = func::max(ans,(a[i] + atk[i] - 1) / atk[i]); printf(&quot;%lld\\n&quot;,ans); &#125;&#125;namespace soln &#123; ll p1[maxn],q1[maxn]; bool init_equotion() &#123; for(int i = 1;i &lt;= n;i ++ ) &#123; ll g = func::gcd(p[i],a[i]); g = func::gcd(g,atk[i]); a[i] /= g,p[i] /= g,atk[i] /= g; if(func::gcd(atk[i],p[i]) != 1) return false; q1[i] = func::fmul(a[i],func::inv(atk[i],p[i]),p[i]); p1[i] = p[i]; &#125; return true; &#125; void excrt() &#123; ll M = p1[1]; ll ans = q1[1]; for(int i = 2;i &lt;= n;i ++) &#123; ll k1,x,y; ll g = func::exgcd(M,p1[i],x,y); ll c = (q1[i] - ans % p1[i] + p1[i]) % p1[i]; if(c % g != 0) &#123; puts(&quot;-1&quot;); return ; &#125; k1 = func::fmul(x,c / g,p1[i] / g); ans = M * k1 + ans; M = M / g * p1[i]; ans = (ans % M + M) % M; &#125; ans = (ans % M + M) % M; printf(&quot;%lld\\n&quot;,ans); &#125; void solve() &#123; sword.clear(); n = func::read(),m = func::read(); for(int i = 1;i &lt;= n;i ++) a[i] = func::read(); for(int i = 1;i &lt;= n;i ++) p[i] = func::read(); for(int i = 1;i &lt;= n;i ++) award[i] = func::read(); for(int i = 1;i &lt;= m;i ++) sword.insert(func::read()); func::init(); if(sp::check()) sp::solve_sp(); else if(init_equotion()) excrt(); else puts(&quot;-1&quot;); &#125;&#125;int main() &#123; freopen(&quot;dragon.in&quot;,&quot;r&quot;,stdin); freopen(&quot;dragon.out&quot;,&quot;w&quot;,stdout); t = func::read(); for(;t;t --) soln::solve(); fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/"},{"name":"题解","slug":"编程/题解","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://resorie.github.io/blog/tags/OI/"}]},{"title":"浅谈珂朵莉树（ODT）","slug":"about-ODT","date":"2020-10-03T05:44:09.000Z","updated":"2020-10-07T14:04:10.991Z","comments":true,"path":"posts/about-ODT/","link":"","permalink":"https://resorie.github.io/blog/posts/about-ODT/","excerpt":"0x00 Prologue在太阳西斜的这个世界里， 置身天上之森。 等这场战争结束之后， 不归之人与望眼欲穿的众人， 人人本着正义之名， 长存不灭的过去、逐渐消逝的未来。 我回来了，纵使日薄西山，即便看不到未来， 此时此刻的光辉，盼君勿忘。 这几天闲着慌，就去学了学珂朵莉树，作为一个很有用的骗分数据结构，个人认为还是有必要学一学的。","text":"0x00 Prologue在太阳西斜的这个世界里， 置身天上之森。 等这场战争结束之后， 不归之人与望眼欲穿的众人， 人人本着正义之名， 长存不灭的过去、逐渐消逝的未来。 我回来了，纵使日薄西山，即便看不到未来， 此时此刻的光辉，盼君勿忘。 这几天闲着慌，就去学了学珂朵莉树，作为一个很有用的骗分数据结构，个人认为还是有必要学一学的。 反正又不难 0x01 What is it?珂朵莉树起源于Codeforces 896 C，由于出题人的CF id为Old Driver，因此又被称为Old Driver Tree（ODT）。 原题需要我们实现一种数据结构，可以快速维护以下操作：（保证数据随机） 区间加； 区间赋值； 求区间第 $k$ 小； 求区间 $k$ 次方和。 很明显，普通的线段树等数据结构都很难实现这种要求，但是这种似乎很复杂的数据结构，在出题人这位毒瘤眼中竟然可以用…… 暴力实现？ 珂朵莉树的思想在于把一段连续的值相同的区间用一个结构体来存储，由于数据随机且有大量区间赋值操作，这样的结构体数量会大大减少，从而保证了珂朵莉树接近线性的时间复杂度。 乍一看，珂朵莉树似乎并不像是一个树形数据结构，但因为它一般基于 $std::set$ 来实现，而 $std::set$ 本质是红黑树，所以也跟“树”勉强搭得上边。 0x02 如何实现？珂朵莉树的精髓在于区间推平操作会产生大量的元素值相同的区间，因此我们用三个变量 $l,r,v$ 来表示一个下标为 $[l,r]$ 中元素值为 $v$ 的区间。接着我们把这些三元组存储到 $std::set$ 中。写成代码就是这样的： 12345678struct node &#123; int l,r; mutable int v; // 这里mutable关键字保证了可以直接在set中修改v的值 node() &#123;&#125; node(int L,int R,int V): l(L),r(R),v(V) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125; // 按照区间所在的位置排序&#125;; typedef set &lt; node &gt; :: iterator iter; // 简化迭代器set &lt; node &gt; s; // 存储到std::set中 比如当输入数据为1 2 2 2 3 3 4 4时， $set$ 内存储的数据就是这样的： 操作1：split然而，我们操作的区间并不总是正好覆盖我们存储的区间。因此我们需要一个函数来实现分裂开每个区间的操作，也就是split函数。split函数接受一个参数 $pos$ ，然后把包含 $pos$ 的区间 $[l,r]$ “分裂”成 $[l,pos)$ 和 $[pos,r]$ ： 123456789iter split(ll pos) &#123; iter it = s.lower_bound(node(pos,0,0)); // lower_bound寻找包含pos的区间 if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; // 如果已经存在就直接返回 it --; // 往前数一个才是我们想要的 ll l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); // 删除原来的 s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first; // 分裂成两个并返回后面一个的迭代器&#125; 对于刚才那个图，如果我们执行split(4)，那么他就会变成这样： 这里的运行流程：lower_bound找到区间 $$ ，往前回滚找到 $$ ，并将其修改成 $$ 和 $$ 。 在进行区间操作时，我们常常要左右端点各split一次，此时我们要先split右端点，否则左端点的迭代器可能会失效而导致错误。 操作2：assign很明显，如果操作中全是split的话，区间数会越来越多，复杂度必然爆炸。这时我们就需要区间赋值操作减少区间数量：assign。 assign函数接受三个参数，表示区间和要赋的值。赋值时，把左右端点split一下，然后把中间的部分变成一个新的区间就行了： 12345void assign(ll l,ll r,ll v) &#123; iter itr = split(r + 1),itl = split(l); // 左右端点各split一遍 s.erase(itl,itr); // 两端点之间的节点全部删去 s.insert(node(l,r,v)); // 插入新的区间&#125; 还是刚刚那个图，如果我们执行assign(3,5,5)，就变成了这个亚子： 其他操作：暴力出奇迹区间加：一个一个加一遍就完事了 1234void add(int l,int r,int x) &#123; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) itl -&gt; v += x;&#125; 区间第 $k$ 大：塞到 $vector$ 里排序就完事了 1234567891011int kth(int l,int r,int k) &#123; vector &lt; pair &lt; int,int &gt; &gt; vec; // pair存储值以及区间长度 iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) vec.push_back(make_pair(itl -&gt; v,itl -&gt; r - itl -&gt; l + 1)); sort(vec.begin(),vec.end()); // 默认优先按照第一关键字排序 for(int i = 0;i &lt; vec.size();i ++) &#123; k -= vec[i].second; if(k &lt;= 0) return vec[i].first; &#125;&#125; 区间 $k$ 次方和：每个取出来做快速幂求和就完事了 1234567int sum(int l,int r,int x,int y) &#123; // x次方和除以y的余数 int res = 0; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) res = (res + (itl -&gt; r - itl -&gt; l + 1) % y * fpow(itl -&gt; v,x,y) % y) % y; // fpow就是快速幂 return res;&#125; 真的是暴力出奇迹……然而因为split和assign的存在， $set$ 中的区间数量也不会太多，所以速度可以保证。不过如果数据不随机，珂朵莉树还是很容易被hack掉的。比如CF896C中提供了一个随机数生成器就是为了防止hack。 最后附上CF896C的全部代码： 查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long ll;struct node &#123; ll l,r; mutable ll v; node() &#123;&#125; node(ll _l,ll _r,ll _v): l(_l),r(_r),v(_v) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125;&#125;; typedef set &lt; node &gt; :: iterator iter;set &lt; node &gt; s;ll n,m,seed,vmax,op,l,r,x,y;ll a[100005];ll rnd(ll mod) &#123; ll ret = seed; seed = (seed * 7 + 13) % 1000000007; return ret % mod + 1;&#125;ll fpow(ll a, ll b, ll mod) &#123; ll res = 1,ans = a % mod; while(b) &#123; if(b &amp; 1) res = res * ans % mod; ans = ans * ans % mod; b &gt;&gt;= 1; &#125; return res;&#125;iter split(ll pos) &#123; iter it = s.lower_bound(node(pos,0,0)); if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; it --; ll l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first;&#125;void assign(ll l,ll r,ll v) &#123; iter itr = split(r + 1),itl = split(l); s.erase(itl,itr); s.insert(node(l,r,v));&#125;void add(ll l,ll r,ll x) &#123; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) itl -&gt; v += x;&#125;ll kth(ll l,ll r,ll k) &#123; vector &lt; pair &lt; ll,ll &gt; &gt; vec; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) vec.push_back(make_pair(itl -&gt; v,itl -&gt; r - itl -&gt; l + 1)); sort(vec.begin(),vec.end()); for(int i = 0;i &lt; vec.size();i ++) &#123; k -= vec[i].second; if(k &lt;= 0) return vec[i].first; &#125;&#125;ll sum(ll l,ll r,ll x,ll y) &#123; ll res = 0; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) res = (res + (itl -&gt; r - itl -&gt; l + 1) % y * fpow(itl -&gt; v,x,y) % y) % y; return res;&#125;int main() &#123; scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;seed,&amp;vmax); for(int i = 1;i &lt;= n;i ++) &#123; a[i] = rnd(vmax); s.insert(node(i,i,a[i])); &#125; for(int i = 1;i &lt;= m;i ++) &#123; op = rnd(4),l = rnd(n),r = rnd(n); if(l &gt; r) swap(l,r); if (op == 3) x = rnd(r - l + 1); else x = rnd(vmax); if (op == 4) y = rnd(vmax); switch(op) &#123; case 1: add(l,r,x); break; case 2: assign(l,r,x); break; case 3: printf(&quot;%lld\\n&quot;,kth(l,r,x)); break; case 4: printf(&quot;%lld\\n&quot;,sum(l,r,x,y)); break; &#125; &#125; return 0;&#125; 0x03 更广泛的运用1. CF915E Physical Education Lessons 有两种操作，每次操作把区间内的值全部赋成0或1，求每次操作后整个序列内元素的和。 区间赋值+区间求和，简直是珂朵莉树的模板！不过在这题中，我们可以把sum函数简化掉，只需要在assign中求和即可。 查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;typedef long long ll;struct node &#123; ll l,r; mutable ll v; node() &#123;&#125; node(ll _l,ll _r,ll _v): l(_l),r(_r),v(_v) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125;&#125;; typedef set &lt; node &gt; :: iterator iter;set &lt; node &gt; s;ll n,q,sum; // sum存储区间和iter split(ll pos) &#123; iter it = s.lower_bound(node(pos,0,0)); if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; it --; ll l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first;&#125;void assign(ll l,ll r,ll v) &#123; int cnt = 0,len = 0; // cnt代表区间内的和，len代表区间长度 iter itr = split(r + 1),itl = split(l); for(iter it = itl;it != itr;it ++) &#123; len += (it -&gt; r - it -&gt; l + 1); cnt += it -&gt; v * (it -&gt; r - it -&gt; l + 1); &#125; s.erase(itl,itr); s.insert(node(l,r,v)); if (v == 1) sum += (len - cnt); else sum -= cnt; // 更新sum的值&#125;int main() &#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;q); sum = n,s.insert(node(1,n,1)); for(int l,r,k;q;q --) &#123; scanf(&quot;%lld%lld%lld&quot;,&amp;l,&amp;r,&amp;k); assign(l,r,k == 1 ? 0 : 1); printf(&quot;%lld\\n&quot;,sum); &#125; return 0;&#125; 2. 洛谷P1047 校门外的树我知道这题可以用模拟差分线段树分块做 但如果把区间长度 $L$ 的范围加大到$10^9$，这些方法就不行了。这时我们就要祭出今天的主角：珂朵莉树。 由于 $m$ 的范围并没有那么大，因此区间的数量并不会那么多（在 $O(m)$ 级别）。由于题目只要求实现区间清零的操作，我们可以直接仿照上个例子来完成。 查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;struct node &#123; int l,r; mutable int v; node() &#123;&#125; node(int _l,int _r,int _v): l(_l),r(_r),v(_v) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125;&#125;; typedef set &lt; node &gt; :: iterator iter;set &lt; node &gt; s;int L,m,sum;iter split(int pos) &#123; iter it = s.lower_bound(node(pos,0,0)); if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; it --; int l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first;&#125;void assign(int l,int r) &#123; int cnt = 0,len = 0; iter itr = split(r + 1),itl = split(l); for(iter it = itl;it != itr;it ++) &#123; len += (it -&gt; r - it -&gt; l + 1); cnt += it -&gt; v * (it -&gt; r - it -&gt; l + 1); &#125; s.erase(itl,itr); s.insert(node(l,r,0)); sum -= cnt;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;L,&amp;m); sum = L + 1,s.insert(node(0,L,1)); for(int l,r;m;m --) &#123; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); assign(l,r); &#125; printf(&quot;%d\\n&quot;,sum); return 0;&#125; 如果真的遇到这道题，且不保证数据随机时，珂朵莉树有可能被hack掉，此时这题的正解应该是离散化+差分。 3. 洛谷P2572 [SCOI2010]序列操作一道不错的练习珂朵莉树骗分的题目。很明显，第0,1,3个操作都是珂朵莉树的板子，而其他两个操作只要稍作修改就行了： 查看代码 区间取反：1234void reverse(int l,int r) &#123; // 挨个取出来取反 iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) itl -&gt; v ^= 1; // 值异或1是个简单的取反方法&#125;求区间最大连续1的长度：12345678int query(int l,int r) &#123; int ans = 0,sum = 0; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) // 挨个取出来计数 if(itl -&gt; v) sum += itl -&gt; r - itl -&gt; l + 1; else ans = ans &gt; sum ? ans : sum,sum = 0; return ans &gt; sum ? ans : sum;&#125; 对于本题，有两个注意点：下标从0开始，因此处理时要全部+1；原题出自2010年四川省选，当时的数据较弱，ODT可以轻松过；但在洛谷上，本题数据经过精心构造，普通ODT只能过3个点。这也是一般ODT只能用作骗分手段的原因。 4. 洛谷P2787 语文1（chin1）- 理理思维又是一道ODT骗分题。前两个操作都是ODT基操，第三个操作开桶排序即可。 查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std;struct node &#123; int l,r; mutable int v; node() &#123;&#125; node(int _l,int _r,int _v): l(_l),r(_r),v(_v) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125;&#125;; typedef set &lt; node &gt; :: iterator iter;set &lt; node &gt; s;string buf;int n,m;int a[100005];inline int read() &#123;#define gc c = getchar() int d = 0,f = 0,gc; while(c &lt; 48 || c &gt; 57) f |= (c == &#x27;-&#x27;),gc; while(c &gt; 47 &amp;&amp; c &lt; 58) d = (d &lt;&lt; 1) + (d &lt;&lt; 3) + (c ^ 48),gc;#undef gc return f ? -d : d;&#125;inline int todigit(char c) &#123; // alpha -&gt; digits if(&#x27;A&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;Z&#x27;) return c - &#x27;A&#x27; + 1; if(&#x27;a&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;z&#x27;) return c - &#x27;a&#x27; + 1;&#125;iter split(int pos) &#123; iter it = s.lower_bound(node(pos,0,0)); if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; it --; int l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first;&#125;void assign(int l,int r,int v) &#123; iter itr = split(r + 1),itl = split(l); s.erase(itl,itr); s.insert(node(l,r,v));&#125;inline int query(int l,int r,int k) &#123; int sum = 0; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) if(itl -&gt; v == k) sum += itl -&gt; r - itl -&gt; l + 1; return sum;&#125;void bsort(int l,int r) &#123; int pos = l,cnt[27]; memset(cnt,0,sizeof(cnt)); iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl = erase(itl)) cnt[itl -&gt; v] += itl -&gt; r - itl -&gt; l + 1; for(int i = 1;i &lt;= 26;i ++) if(cnt[i]) s.insert(node(pos,pos + cnt[i] - 1,i)),pos += cnt[i];&#125;int main() &#123; n = read(),m = read(); cin &gt;&gt; buf; for(int i = 1;i &lt;= n;i ++) s.insert(node(i,i,todigit(buf[i - 1]))); for(int op,x,y;m;m --) &#123; op = read(),x = read(),y = read(); char k; if(op != 3) &#123; cin &gt;&gt; k; k = todigit(k); &#125; switch(op) &#123; case 1: printf(&quot;%d\\n&quot;,query(x,y,k)); break; case 2: assign(x,y,k); break; case 3: bsort(x,y); break; &#125; &#125; return 0;&#125; 0x04 Epilogue我永远喜欢珂朵莉！（雾 珂朵莉树作为一个较为简单的数据结构，是在OI比赛中骗分的一个不错的工具蒟蒻选手的福音。在许多复杂的线段树题目中，它能够体现出清晰易懂、代码量小的优势。 所以，大家快来膜拜lxl，lxl是我们的光！","categories":[{"name":"编程","slug":"编程","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/"},{"name":"数据结构","slug":"编程/数据结构","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://resorie.github.io/blog/tags/OI/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/"},{"name":"题解","slug":"编程/题解","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/%E9%A2%98%E8%A7%A3/"},{"name":"数据结构","slug":"编程/数据结构","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://resorie.github.io/blog/tags/OI/"}]}